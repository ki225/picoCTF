This practice is to get the flag from saturn.picoctf.net 64712. In order to connect it, we need to use the command.
```
nc saturn.picoctf.net 64712
```

The C code for this website is here:
```c
//vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler

  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

Before getting the flag, we should know this code first.

In order to print the flag, we need to find the way to call the function below:
```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```

And we find the `sigsegv_handler()` function in the `main` function:

```c
fgets(flag,FLAGSIZE_MAX,f);
signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```

`signal(SIGSEGV, sigsegv_handler);` means that it will call sigsegv_handler() when it get SIGSEGV signal. After googling it, we know that SIGSEGV represents `Segmentation fault`.
Therefore, we have to make Segmentation fault.

From `vuln()`, it seems that Segmentation fault will be happened if we input more than 16 characters.
```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

So I tried
```
Input: 00000000000000000000000
```
here is the flag!
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```


ref: https://zh.wikipedia.org/wiki/記憶體區段錯誤


